<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tomato Robot</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üçÖ</text></svg>">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <style>
        body {
            font-family: Pretendard, sans-serif;
            background-color: #ffffff; 
            width: 100%;
            height: 100%;
            position: relative;
            overflow-x: hidden;
        }

        .background-circle {
            position: absolute;
            border-radius: 50%;
            background-color: rgba(0, 4, 255, 0.1);
            z-index: -1;
        }
        #circle1 {
            width: 15vw;
            height: 15vw;
            top: 120px;
            right: 10%;
        }
        #circle2 {
            width: 10vw;
            height: 10vw;
            top: 350px;
            left: 10%;
        }
        #circle3 {
            width: 10vw;
            height: 10vw;
            top: 500px;
            right: 25%;
        }
        #circle4 {
            width: 25vw;
            height: 25vw;
            top: 800px;
            left: 0px;
        }
        #circle5 {
            width: 5vw;
            height: 5vw;
            top: 100px;
            left: 5%;
        }
        #circle6 {
            width: 20vw;
            height: 20vw;
            top: 900px;
            right: 5%;
        }
        
        #head-container { 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            height: 50px;
            padding: 0 25px;
        }
        .switch-container {
            display: flex;
            align-items: center;
            gap: 20px;
        }
        .switch-group {
            display: flex;
            align-items: center;
        }
        .switch-label {
            color: #0004FF;
            font-weight: bold;
            margin-right: 10px;
            font-size: 20px;
        }
        .switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 30px;
        }
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 4, 255, 0.1);
            transition: .4s;
            border-radius: 34px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 22px;
            width: 22px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: #0004FF;
        }
        input:focus + .slider {
            box-shadow: 0 0 1px #0004FF;
        }
        input:checked + .slider:before {
            transform: translateX(30px);
        }
        
        #body-container { 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: center; 
            width: 100%; 
            height: 100%; 
            margin-top: 20vh;
            position: relative;
            z-index: 1;
        }
        
        #title { 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            width: 100%; 
            height: 50px; 
            margin-bottom: 20px; 
        }
        
        #title p { 
            color: #0004FF; 
            font-size: 32px; 
            font-weight: bold; 
            margin-bottom: 20px; 
        }

        #stream-container { 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            width: 90%;  
            border-radius: 15px; 
            padding: 20px; 
        }

        #stream-screen { 
            width: 50%;
            display: flex; 
            flex-direction: column; 
            justify-content: center; 
            align-items: center;
        }

        #video_feed { 
            width: 100%; 
            border-radius: 15px; 
            margin: 20px auto; 
            display: block; 
        }

        #waiting-screen { 
            display: flex; 
            flex-direction: column; 
            justify-content: center; 
            align-items: center; 
            width: 100%; 
        }
        
        #waiting-screen h1 { 
            color: #0004FF; 
            font-size: 28px; 
            font-weight: bold; 
            margin-bottom: 20px; 
        }
        
        #waiting-screen p { 
            color: #aaaaaa; 
            font-size: 20px; 
            margin-bottom: 20px; 
        }

        #tomato-screen {
            display: flex;
            margin: 20px auto;
            justify-content: center; 
            align-items: center; 
        }

        #mode-indicator {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 5px 15px;
            border-radius: 15px;
            background-color: rgba(0, 4, 255, 0.1);
            color: #0004FF;
            font-weight: bold;
            font-size: 16px;
        }

        #logging-message {
            position: fixed;
            bottom: -100px;
            left: 0;
            width: 100%;
            text-align: center;
            padding: 15px;
            background-color: rgba(0, 4, 255, 0.1);
            color: #0004FF;
            font-weight: bold;
            font-size: 18px;
            z-index: 1000;
            transition: bottom 0.5s ease-in-out;
            pointer-events: none;
        }

        #logging-message.show {
            bottom: 30px !important;
        }

        #save-notification {
            position: fixed;
            bottom: 90px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            background-color: #0004FF;
            color: white;
            border-radius: 20px;
            font-weight: bold;
            opacity: 0;
            visibility: hidden;
            z-index: 1001;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
            pointer-events: none;
        }

        #save-notification.show {
            opacity: 1;
            visibility: visible;
        }

        .countdown-container {
            position: relative;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        .countdown-circle {
            position: absolute;
            width: 60px;
            height: 60px;
            transform: translate(-50%, -50%);
            left: 50%;
            top: 50%;
        }

        .countdown-circle svg {
            transform: rotate(-90deg);
            width: 60px;
            height: 60px;
        }

        .countdown-circle circle {
            fill: none;
            stroke-width: 3;
        }

        .countdown-background {
            stroke: rgba(0, 4, 255, 0.1);
        }

        .countdown-progress {
            stroke: #0004FF;
            background-color: rgba(0, 4, 255, 0.1);
            transition: stroke-dashoffset 0.1s linear;
        }

        .countdown-number {
            position: relative;
            z-index: 1;
            font-size: 24px;
            font-weight: bold;
            color: #0004FF;
            margin: 0 10px;
        }
    </style>
</head>
<body>
    <audio id="popSound" src="{{ url_for('static', filename='audio/pop.mp3') }}" preload="auto"></audio>
    <audio id="alertSound" src="{{ url_for('static', filename='audio/alert.mp3') }}" preload="auto"></audio>
    <audio id="successSound" src="{{ url_for('static', filename='audio/success.mp3') }}" preload="auto"></audio>
    
    <div class="background-circle" id="circle1"></div>
    <div class="background-circle" id="circle2"></div>
    <div class="background-circle" id="circle3"></div>
    <div class="background-circle" id="circle4"></div>
    <div class="background-circle" id="circle5"></div>
    <div class="background-circle" id="circle6"></div>

    <div id="head-container">
        <p style="color: #0004FF; font-size: 32px; font-weight: bold;">Tomato Robot ü§ñ</p>
        <div class="switch-container">
            <div id="mode-indicator">Mode: Inference</div>
            <div class="switch-group">
                <span class="switch-label">Video On/Off</span>
                <label class="switch">
                    <input type="checkbox" id="video-toggle" checked>
                    <span class="slider"></span>
                </label>
            </div>
        </div>
    </div>
    
    <div id="body-container">
        <div id="title"><p>ÏïàÎÖïÌïòÏÑ∏Ïöîüôå</p></div>

        <div id="waiting-screen">
            <canvas id="canvas-hand"></canvas>
            <h1>Ïπ¥Î©îÎùºÎ•º Ìñ•Ìï¥ ÏÜêÏùÑ ÎÇ¥Î∞ÄÏñ¥ Ï£ºÏÑ∏Ïöî!</h1>
            <p>waiting for hand...</p>
        </div>

        <div id="stream-container">
            <div id="stream-screen" style="display:block;">
                <img id="video_feed" src="" alt="Video Feed">
                <div id="tomato-screen" style="display:block;">
                    <canvas id="canvas-tomato"></canvas>
                </div>
            </div>
        </div>
    </div>
    
    <div id="logging-message">1-4 ÌÇ§Î•º ÎàåÎü¨ ÌÜ†ÎßàÌÜ† Ï¢åÌëúÎ•º Ï†ÄÏû•ÌïòÏÑ∏Ïöî (ESC: Ïù∏ÌçºÎü∞Ïä§ Î™®ÎìúÎ°ú ÎèåÏïÑÍ∞ÄÍ∏∞)</div>
    <div id="save-notification"></div>
    
    <script>
        var socket = io();
        var streaming = false;
        var firstFrameReceived = false;
        var currentMatchedTomatoId = null;
        var lastMatchedTomatoTime = 0;
        var sameIdDuration = 0;
        var harvestingTomato = false;
        var videoEnabled = localStorage.getItem('videoEnabled') !== 'false';
        let currentMode = 'inference';
        
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('video-toggle').checked = videoEnabled;
            
            const sounds = ['popSound', 'alertSound', 'successSound'];
            sounds.forEach(soundId => {
                const audio = document.getElementById(soundId);
                audio.load();

                audio.addEventListener('loadeddata', () => {
                    console.log(`${soundId} loaded successfully`);
                });
            
                audio.addEventListener('error', (e) => {
                    console.error(`Error loading ${soundId}:`, e);
                });
            });
            
            startStream();
            toggleVideoFeed();
            toggleTomatoScreen();
            toggleUI(false);
            currentMode = 'inference';
            const loggingMessage = document.getElementById('logging-message');
            if (loggingMessage) {
                loggingMessage.classList.remove('show');
            }
        });

        function toggleUI(showStream) {
            document.getElementById('waiting-screen').style.display = showStream ? 'none' : 'flex';
            document.getElementById('stream-screen').style.display = showStream ? 'block' : 'none';

            if (!showStream) {
                currentMatchedTomatoId = null;
                sameIdDuration = 0;
                harvestingTomato = false;
            } else {
                toggleVideoFeed();
                toggleTomatoScreen();
            }
            updateTitleMessage();
        }

        document.getElementById('video-toggle').addEventListener('change', function(e) {
            videoEnabled = e.target.checked;
            localStorage.setItem('videoEnabled', videoEnabled);
            
            toggleVideoFeed();
            toggleTomatoScreen();
        });

        function toggleVideoFeed() {
            const videoFeed = document.getElementById('video_feed');
            if (videoEnabled) {
                videoFeed.style.display = 'block';
            } else {
                videoFeed.style.display = 'none';
            }
        }

        function toggleTomatoScreen() {
            const tomatoScreen = document.getElementById('tomato-screen');
            if (!videoEnabled) {
                tomatoScreen.style.display = 'flex';
            } else {
                tomatoScreen.style.display = 'none';
            }
        }

        socket.on('video_frame', function(data) {
            if (streaming) {
                document.getElementById('video_feed').src = 'data:image/jpeg;base64,' + data.image;
                
                if (!firstFrameReceived) {
                    firstFrameReceived = true;
                    toggleUI(true);
                }
            }
        });

        socket.on('segment_status', function(data) {
            if (data.detected) {
                if (data.resumed) {
                    console.log("Stream resumed");
                    toggleUI(true);
                }
            } else if (data.timeout) {
                console.log("Hand not detected for 5 seconds, stream paused");
                toggleUI(false);
            }
        });

        const popSound = document.getElementById('popSound');
        const alertSound = document.getElementById('alertSound');
        const successSound = document.getElementById('successSound');
        let lastMatchedId = null;
        
        socket.on('tomato_match_result', function(data) {
            const now = Date.now();
            
            if (data.matched_id !== null && data.matched_id !== lastMatchedId) {
                popSound.currentTime = 0;
                popSound.play().catch(function(error) {
                    console.log("Audio play failed:", error);
                });
                lastMatchedId = data.matched_id;
            }
            
            if (data.matched_id === null || data.matched_id !== currentMatchedTomatoId) {
                if (currentMatchedTomatoId !== null) {
                    window.updateTomatoHighlight(currentMatchedTomatoId, false);
                }
                
                sameIdDuration = 0;
                harvestingTomato = false;
                currentMatchedTomatoId = data.matched_id;
                if (currentMatchedTomatoId !== null) {
                    lastMatchedTomatoTime = now;
                    window.updateTomatoHighlight(currentMatchedTomatoId, true);
                }
            } 
            else if (data.matched_id === currentMatchedTomatoId) {
                sameIdDuration = now - lastMatchedTomatoTime;
                
                if (sameIdDuration >= 4500 && !harvestingTomato) {
                    harvestingTomato = true;
                    alertSound.currentTime = 0;
                    alertSound.play().catch(function(error) {
                        console.log("Alert sound play failed:", error);
                    });
                    socket.emit('execute_robot_sequence', {
                        tomato_id: currentMatchedTomatoId
                    });
                }
            }
            updateTitleMessage();
        });

        socket.on('robot_sequence_complete', function(data) {
            if (data.tomato_id === currentMatchedTomatoId) {
                successSound.currentTime = 0;
                successSound.play().catch(function(error) {
                    console.log("Success sound play failed:", error);
                });
                
                document.getElementById('title').innerHTML = 
                    `<p><span style="background-color: rgba(0, 4, 255, 0.1); padding: 5px; border-radius: 25px;">${data.tomato_id}Î≤à ÌÜ†ÎßàÌÜ†</span>Î•º ÏàòÌôï ÏôÑÎ£åÌïòÏòÄÏäµÎãàÎã§! ‚ú®</p>`;
                window.updateTomatoHighlight(currentMatchedTomatoId, false);
                currentMatchedTomatoId = null;
            }
        });

        socket.on('mode_change', function(data) {
            const modeIndicator = document.getElementById('mode-indicator');
            const loggingMessage = document.getElementById('logging-message');
            
            if (!loggingMessage) {
                console.error('logging-message element not found');
                return;
            }
            
            modeIndicator.textContent = `Mode: ${data.mode.charAt(0).toUpperCase() + data.mode.slice(1)}`;
            currentMode = data.mode;
            
            console.log('Mode changed to:', data.mode);
            
            if (data.mode === 'logging') {
                loggingMessage.classList.add('show');
                console.log('Added show class');
            } else {
                loggingMessage.classList.remove('show');
                console.log('Removed show class');
            }
        });

        function createCountdownCircle() {
            const container = document.createElement("div");
            container.className = "countdown-container";
            
            const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            
            const backgroundCircle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            backgroundCircle.setAttribute("cx", "30");
            backgroundCircle.setAttribute("cy", "30");
            backgroundCircle.setAttribute("r", "25");
            backgroundCircle.setAttribute("class", "countdown-background");
            
            const progressCircle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            progressCircle.setAttribute("cx", "30");
            progressCircle.setAttribute("cy", "30");
            progressCircle.setAttribute("r", "25");
            progressCircle.setAttribute("class", "countdown-progress");
            
            const circumference = 2 * Math.PI * 25;
            progressCircle.style.strokeDasharray = circumference;
            progressCircle.style.strokeDashoffset = circumference;
            
            svg.appendChild(backgroundCircle);
            svg.appendChild(progressCircle);
            
            const circleContainer = document.createElement("div");
            circleContainer.className = "countdown-circle";
            circleContainer.appendChild(svg);
            
            const numberSpan = document.createElement("span");
            numberSpan.className = "countdown-number";
            
            container.appendChild(circleContainer);
            container.appendChild(numberSpan);
            
            return { container, progressCircle, circumference, numberSpan };
        }

        function updateTitleMessage() {
            if (!streaming || !firstFrameReceived || document.getElementById('waiting-screen').style.display === 'flex') {
                document.getElementById('title').innerHTML = '<p>ÏïàÎÖïÌïòÏÑ∏Ïöîüôå</p>';
                return;
            }

            if (currentMatchedTomatoId !== null) {
                if (harvestingTomato) {
                    document.getElementById('title').innerHTML = 
                        `<p><span style="background-color: rgba(0, 4, 255, 0.1); padding: 5px; border-radius: 25px;">${currentMatchedTomatoId}Î≤à ÌÜ†ÎßàÌÜ†</span>Î•º ÏàòÌôï Ï§ëÏûÖÎãàÎã§... ‚úÇÔ∏è</p>`;
                } 
                else if (sameIdDuration >= 1500) {
                    if (sameIdDuration < 4500) {
                        const { container, progressCircle, circumference, numberSpan } = createCountdownCircle();
                        const progress = (sameIdDuration - 1500) / 3000;
                        const offset = circumference * (1 - progress);
                        progressCircle.style.strokeDashoffset = offset;
                        
                        const remainingTime = Math.ceil((4.5 - sameIdDuration/1000));
                        numberSpan.textContent = remainingTime;
                        
                        const titleElement = document.createElement('p');
                        titleElement.innerHTML = 
                            `Í≥ÑÏÜç Í∞ÄÎ¶¨ÌÇ§Î©¥ <span style="display: inline-flex; align-items: center; padding: 5px 15px; border-radius: 25px;">${container.outerHTML}</span> ÌõÑÏóê <span style="background-color: rgba(0, 4, 255, 0.1); padding: 5px; border-radius: 25px;">${currentMatchedTomatoId}Î≤à ÌÜ†ÎßàÌÜ†</span>Î•º ÏàòÌôïÌï©ÎãàÎã§ üçÖ`;
                        
                        document.getElementById('title').innerHTML = '';
                        document.getElementById('title').appendChild(titleElement);
                    }
                }
                else {
                    document.getElementById('title').innerHTML = 
                        `<p><span style="background-color: rgba(0, 4, 255, 0.1); padding: 5px; border-radius: 25px;">${currentMatchedTomatoId}Î≤à ÌÜ†ÎßàÌÜ†</span>Í∞Ä ÎßûÏúºÏã†Í∞ÄÏöî? ü§î</p>`;
                }
            } else {
                if (document.getElementById('stream-screen').style.display === 'block') {
                    lastMatchedId = null;
                    document.getElementById('title').innerHTML = 
                        '<p>ÏàòÌôïÌïòÍ≥†Ïûê ÌïòÎäî <span style="background-color: rgba(0, 4, 255, 0.1); padding: 5px; border-radius: 25px;">ÌÜ†ÎßàÌÜ†</span>Î•º ÏÜêÏúºÎ°ú Í∞ÄÎ¶¨ÏºúÏ£ºÏÑ∏Ïöî üëÜüèª</p>';
                } else {
                    document.getElementById('title').innerHTML = '<p>ÏïàÎÖïÌïòÏÑ∏Ïöîüôå</p>';
                }
            }
        }

        function startStream() {
            socket.emit('start_stream');
            streaming = true;
        }

        // modify the keyboard event listener
        document.addEventListener('keydown', function(event) {
            // l key always works (for mode switching)
            if (event.key.toLowerCase() === 'l') {
                socket.emit('key_press', { key: 'l' });
                return;
            }
            
            // zoom in/out
            if (event.key === '+' || event.key === '=' || event.key === '-' || event.key === '_') {
                socket.emit('key_press', { key: event.key });
                return;
            }
            
            // process other keys only when in logging mode
            if (currentMode === 'logging') {
                // ESC key
                if (event.key === 'Escape') {
                    socket.emit('key_press', { key: 'Escape' });
                }
                // 1-4 ÌÇ§
                else if (['1', '2', '3', '4'].includes(event.key)) {
                    socket.emit('key_press', { key: event.key });
                }
            }
        });

        // event listener for the coordinate saved message
        socket.on('coordinate_saved', function(data) {
            const notification = document.getElementById('save-notification');
            notification.textContent = `${data.tomato_id}Î≤à ÌÜ†ÎßàÌÜ†Ïùò Ï¢åÌëúÍ∞Ä Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§!`;
            notification.style.display = 'block';
            
            setTimeout(() => {
                notification.style.display = 'none';
            }, 1500);
        });
    </script>
    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
        function renderHand() {
            const canvas = document.getElementById('canvas-hand');
            const renderer = new THREE.WebGLRenderer({
                canvas, 
                antialias: true,
                alpha: true
            });
            
            const size = Math.max(window.innerWidth, window.innerHeight);
            renderer.setSize(size * 0.2, size * 0.2);
            
            renderer.setClearColor(0x000000, 0);

            const fov = 75;
            const aspect = canvas.clientWidth / canvas.clientHeight;
            const near = 0.1;
            const far = 100;

            const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
            camera.position.z = 7;
            camera.position.y = 0;

            const scene = new THREE.Scene();

            // Lighting
            {
                const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
                scene.add(ambientLight);
                
                const mainLight = new THREE.DirectionalLight(0xffffff, 0.5);
                mainLight.position.set(5, 10, 7);
                scene.add(mainLight);
            }

            const handModel = createCuteHand();
            handModel.scale.set(0.55, 0.55, 0.55);
            scene.add(handModel);
            
            function createFingers(handGroup, material) {
                const fingerPositions = [
                    { x: -2, z: 3.5, scale: 0.9, rotationX: -0.1, name: "ÏÜåÏßÄ" },
                    { x: -0.7, z: 4, scale: 1, rotationX: 0, name: "ÏïΩÏßÄ" },
                    { x: 0.7, z: 4.2, scale: 1.1, rotationX: 0, name: "Ï§ëÏßÄ" },
                    { x: 2, z: 3.8, scale: 0.95, rotationX: 0.1, name: "Í≤ÄÏßÄ" }
                ];
                
                fingerPositions.forEach(fp => {
                    const finger = createCuteFinger(material, fp.scale);
                    finger.position.set(fp.x, 0, fp.z);
                    finger.rotation.x = fp.rotationX;
                    handGroup.add(finger);
                });
                
                const thumb = createCuteFinger(material, 0.9);
                thumb.position.set(2, 0, 1);
                thumb.rotation.z = -Math.PI / 4;
                thumb.rotation.y = Math.PI / 5;
                handGroup.add(thumb);
            }
            
            function createCuteFinger(material, scale = 1) {
                const fingerGroup = new THREE.Group();
                
                const segmentGeometry = new THREE.CylinderGeometry(0.8 * scale, 0.6 * scale, 2.5 * scale, 8);
                const segment = new THREE.Mesh(segmentGeometry, material);
                segment.rotation.x = Math.PI / 2;
                segment.position.z = 1.2 * scale;
                fingerGroup.add(segment);
                
                const tipGeometry = new THREE.SphereGeometry(0.8 * scale, 8, 8);
                const tip = new THREE.Mesh(tipGeometry, material);
                tip.position.z = 2.5 * scale;
                fingerGroup.add(tip);
                
                return fingerGroup;
            }
            
            function createCuteHand() {
                const handGroup = new THREE.Group();
                const handMaterial = new THREE.MeshLambertMaterial({
                    color: 0xFFDFC4,
                    emissive: 0x884548
                });
                
                const palmGeometry = new THREE.SphereGeometry(2.5, 32, 32);
                const palm = new THREE.Mesh(palmGeometry, handMaterial);
                palm.scale.set(1.2, 0.8, 1.5);
                palm.position.set(0, 0, 1);
                handGroup.add(palm);
                
                createFingers(handGroup, handMaterial);
                
                return handGroup;
            }
            
            // Animation
            function render(time) {
                time *= 0.001;
                
                handModel.rotation.y = Math.sin(time * 0.5) * 0.3;
                handModel.rotation.x = Math.sin(time * 0.7) * 0.1 + 0.2;
                handModel.position.y = Math.sin(time * 1.5) * 0.5;
                
                renderer.render(scene, camera);
                requestAnimationFrame(render);
            }
            
            window.addEventListener('resize', () => {
                const width = window.innerWidth * 0.5;
                const height = window.innerWidth * 0.5;
                
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
                
                renderer.setSize(width, height);
            });
            
            requestAnimationFrame(render);
        }

        function renderTomatoTree() {
            const canvas = document.getElementById('canvas-tomato');
            const renderer = new THREE.WebGLRenderer({
                canvas,
                antialias: true,
                alpha: true
            });

            const size = Math.max(window.innerWidth, window.innerHeight);
            renderer.setSize(size * 0.3, size * 0.3);
            
            renderer.setClearColor(0x000000, 0);

            const fov = 75;
            const aspect = canvas.clientWidth / canvas.clientHeight;
            const near = 0.1;
            const far = 100;

            const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
            camera.position.set(0, 2, 5);
            camera.lookAt(0, 0, 0);

            const scene = new THREE.Scene();

            // lighting setup
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 5, 5);
            scene.add(ambientLight, directionalLight);

            // create the tree stem
            const stemGroup = new THREE.Group();
            
            const mainStemShape = new THREE.Shape();
            mainStemShape.moveTo(-0.15, -3);
            mainStemShape.lineTo(0.15, -3);
            mainStemShape.lineTo(0, 3);
            mainStemShape.lineTo(-0.15, -3);

            const extrudeSettings = {
                steps: 1,
                depth: 0.3,
                bevelEnabled: false
            };

            const mainStemGeometry = new THREE.ExtrudeGeometry(mainStemShape, extrudeSettings);
            const stemMaterial = new THREE.MeshPhongMaterial({ color: 0x2d5a27 });
            const mainStem = new THREE.Mesh(mainStemGeometry, stemMaterial);
            mainStem.position.z = -0.15;
            stemGroup.add(mainStem);

            // left branch (cone)
            const leftBranchGeometry = new THREE.ConeGeometry(0.15, 2, 8);
            const leftBranch = new THREE.Mesh(leftBranchGeometry, stemMaterial);
            leftBranch.position.set(-0.95, 1, 0);
            leftBranch.rotation.z = Math.PI / 2.5;
            stemGroup.add(leftBranch);

            // right branch (cone)
            const rightBranchGeometry = new THREE.ConeGeometry(0.15, 2, 8);
            const rightBranch = new THREE.Mesh(rightBranchGeometry, stemMaterial);
            rightBranch.position.set(1, -1, 0);
            rightBranch.rotation.z = -Math.PI / 2.5;
            stemGroup.add(rightBranch);

            scene.add(stemGroup);

            // function to create tomatoes and stems
            function createTomatoWithStem(position, index) {
                const tomatoGroup = new THREE.Group();
                
                // create the stem shape
                const stemShape = new THREE.Shape();
                stemShape.moveTo(-0.1, 0);    // starting point
                stemShape.lineTo(0.1, 0);     // bottom width
                stemShape.lineTo(0, 0.3);     // top pointy part
                stemShape.lineTo(-0.1, 0);    

                const stemExtrudeSettings = {
                    steps: 1,
                    depth: 0.1,
                    bevelEnabled: false
                };

                const stemGeometry = new THREE.ExtrudeGeometry(stemShape, stemExtrudeSettings);
                const stemMaterial = new THREE.MeshPhongMaterial({ color: 0x2d5a27 });
                const stem = new THREE.Mesh(stemGeometry, stemMaterial);
                stem.position.set(0, 0.4, 0);
                stem.rotation.z = Math.PI;

                // add the stem leaf (small triangles 2)
                const leafShape1 = new THREE.Shape();
                leafShape1.moveTo(0, 0);
                leafShape1.lineTo(0.2, 0.1);
                leafShape1.lineTo(0, 0.2);
                leafShape1.lineTo(0, 0);

                const leafShape2 = new THREE.Shape();
                leafShape2.moveTo(0, 0);
                leafShape2.lineTo(-0.2, 0.1);
                leafShape2.lineTo(0, 0.2);
                leafShape2.lineTo(0, 0);

                const leafGeometry1 = new THREE.ExtrudeGeometry(leafShape1, stemExtrudeSettings);
                const leafGeometry2 = new THREE.ExtrudeGeometry(leafShape2, stemExtrudeSettings);
                
                const leaf1 = new THREE.Mesh(leafGeometry1, stemMaterial);
                const leaf2 = new THREE.Mesh(leafGeometry2, stemMaterial);
                
                leaf1.position.set(0, 0.4, 0);
                leaf2.position.set(0, 0.4, 0);
                
                // tomato creation
                const tomatoGeometry = new THREE.SphereGeometry(0.4, 16, 16);
                const tomatoMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000 });
                const tomato = new THREE.Mesh(tomatoGeometry, tomatoMaterial);
                
                tomato.userData.id = index + 1;
                
                // create the number texture
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = canvas.height = 128;
                context.fillStyle = 'white';
                context.font = 'bold 64px Arial';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(index + 1, 64, 64);
                
                const numberTexture = new THREE.CanvasTexture(canvas);
                const numberMaterial = new THREE.MeshBasicMaterial({ 
                    map: numberTexture,
                    transparent: true
                });
                
                const numberPlane = new THREE.Mesh(
                    new THREE.PlaneGeometry(0.3, 0.3),
                    numberMaterial
                );
                numberPlane.position.z = 0.41;
                tomato.add(numberPlane);

                tomatoGroup.add(tomato);
                tomatoGroup.add(stem);
                tomatoGroup.add(leaf1);
                tomatoGroup.add(leaf2);

                tomatoGroup.position.set(position.x, position.y, position.z);

                return tomatoGroup;
            }

            // set the position of the tomatoes and create them
            const tomatoPositions = [
                { x: -1.8, y: 0, z: 0 },
                { x: -0.8, y: 0, z: 0 },    // two tomatoes on the left
                { x: 0, y: 2.5, z: 0 },     // top
                { x: 1, y: -2, z: 0 }       // bottom right
            ];

            const treeGroup = new THREE.Group();
            treeGroup.add(stemGroup);

            tomatoPositions.forEach((pos, index) => {
                const tomatoWithStem = createTomatoWithStem(pos, index);
                treeGroup.add(tomatoWithStem);
            });

            scene.add(treeGroup);

            // smooth animation for the tree
            function animate() {
                requestAnimationFrame(animate);
                const time = Date.now() * 0.001;
                const floatHeight = Math.sin(time) * 0.1;
                treeGroup.position.y = floatHeight;
                renderer.render(scene, camera);
            }
            animate();

            // tomato color change function
            function updateTomatoColor(id, isSelected) {
                treeGroup.traverse((child) => {
                    if (child instanceof THREE.Mesh && child.userData.id === id) {
                        if (child.material.color) {
                            if (child.parent.userData.animationId) {
                                cancelAnimationFrame(child.parent.userData.animationId);
                            }

                            if (isSelected) {
                                // set the material of the selected tomato
                                child.material.color.setHex(0xff0000);  // default red color
                                child.material.emissive = new THREE.Color(0xaaaaaa);  // intensity of the light
                                child.material.emissiveIntensity = 0.5;  // intensity of the light
                                
                                // animation for the size and the intensity of the light
                                const pulseAnimation = () => {
                                    const time = Date.now() * 0.001;
                                    const pulseFactor = 1.2 + Math.sin(time * 3) * 0.05;
                                    child.parent.scale.set(pulseFactor, pulseFactor, pulseFactor);
                                    
                                    child.material.emissiveIntensity = 0.5 + Math.sin(time * 5) * 0.3;
                                };
                                
                                function animate() {
                                    pulseAnimation();
                                    child.parent.userData.animationId = requestAnimationFrame(animate);
                                }
                                animate();
                            } else {
                                // if not selected, set the color to the original color
                                child.material.color.setHex(0xff0000);
                                child.material.emissive = new THREE.Color(0x000000);
                                child.material.emissiveIntensity = 0;
                                
                                const startScale = child.parent.scale.x;
                                const startTime = Date.now();
                                const duration = 500;

                                function shrinkAnimation() {
                                    const currentTime = Date.now();
                                    const elapsed = currentTime - startTime;
                                    const progress = Math.min(elapsed / duration, 1);
                                    
                                    // easeOutQuad Ïù¥Ïßï Ìï®Ïàò Ï†ÅÏö©
                                    const scale = startScale + (1 - startScale) * (1 - Math.pow(1 - progress, 2));
                                    child.parent.scale.set(scale, scale, scale);

                                    if (progress < 1) {
                                        child.parent.userData.animationId = requestAnimationFrame(shrinkAnimation);
                                    } else {
                                        child.parent.userData.animationId = null;
                                    }
                                }
                                
                                shrinkAnimation();
                            }
                        }
                    }
                });
            }
            
            // Add this line to make the updateTomatoHighlight function available to the global scope
            window.updateTomatoHighlight = updateTomatoColor;
        }   

        renderHand();
        renderTomatoTree();
        
    </script>
</body>
</html>